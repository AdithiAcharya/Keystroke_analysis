import tkinter as tk
from tkinter import messagebox
import time
import os
import csv
from dataclasses import dataclass

# This is the Python equivalent of TypedKeyObject.java
@dataclass
class TypedKeyObject:
    """A data class to hold press and release times for a single key event."""
    press_time_ms: int = 0
    release_time_ms: int = 0
    press_time_ns: int = 0
    release_time_ns: int = 0

# This is the Python equivalent of KeyDataStore.java
class KeyDataStore:
    """Stores a sequence of key events and processes them to extract timing features."""
    def __init__(self):
        # A list of TypedKeyObject instances preserves the order of key presses.
        self.store: list[TypedKeyObject] = []

    def initialize(self):
        """Clears the store for a new sample."""
        self.store.clear()

    def store_typed_object(self, typed_key_object: TypedKeyObject):
        """Adds a new key press event to the store."""
        self.store.append(typed_key_object)

    def get_key(self, index: int) -> TypedKeyObject | None:
        """Retrieves a key event by its index."""
        if 0 <= index < len(self.store):
            return self.store[index]
        return None

    def process(self) -> list[float] | None:
        """
        Calculates Hold, Down-Down, and Up-Down timings in milliseconds.
        This logic perfectly matches the Java version.
        """
        if len(self.store) < 2:
            print(f"Warning: At least 2 key presses are required. Found: {len(self.store)}")
            return None

        strokes = []
        # Iterate through pairs of consecutive keys
        for i in range(len(self.store) - 1):
            current = self.store[i]
            next_key = self.store[i+1]

            key1_hold_time = current.release_time_ms - current.press_time_ms
            key1_key2_down_time = next_key.press_time_ms - current.press_time_ms
            key1_key2_up_down_time = next_key.press_time_ms - current.release_time_ms

            strokes.append(key1_hold_time / 1000.0)
            strokes.append(key1_key2_down_time / 1000.0)
            strokes.append(key1_key2_up_down_time / 1000.0)

        # Add the hold time of the very last key
        last_key = self.store[-1]
        last_keys_hold_time = last_key.release_time_ms - last_key.press_time_ms
        strokes.append(last_keys_hold_time / 1000.0)

        return strokes
    
    def process_in_nano(self) -> list[int] | None:
        """
        Calculates Hold, Down-Down, and Up-Down timings in nanoseconds.
        """
        if len(self.store) < 2:
            return None
            
        strokes = []
        for i in range(len(self.store) - 1):
            current = self.store[i]
            next_key = self.store[i+1]
            
            key1_hold_time = current.release_time_ns - current.press_time_ns
            key1_key2_down_time = next_key.press_time_ns - current.press_time_ns
            key1_key2_up_down_time = next_key.press_time_ns - current.release_time_ns
            
            strokes.append(key1_hold_time)
            strokes.append(key1_key2_down_time)
            strokes.append(key1_key2_up_down_time)

        last_key = self.store[-1]
        last_keys_hold_time = last_key.release_time_ns - last_key.press_time_ns
        strokes.append(last_keys_hold_time)

        return strokes

# This is the Python equivalent of KeyEventDemo.java
class KeystrokeGuiApp:
    """The main GUI application class."""
    
    # --- Configuration ---
    # Recommended number of samples to collect per user.
    SAMPLES_PER_USER = 20 

    # Updated CSV header to include the "Label" column
    FILE_HEADER = [
        "User", "Label", "H.period", "DD.period.t", "UD.period.t", "H.t", "DD.t.i", "UD.t.i", 
        "H.i", "DD.i.e", "UD.i.e", "H.e", "DD.e.five", "UD.e.five", "H.five", 
        "DD.five.Shift.r", "UD.five.Shift.r", "H.Shift.r", "DD.Shift.r.o", "UD.Shift.r.o", 
        "H.o", "DD.o.a", "UD.o.a", "H.a", "DD.a.n", "UD.a.n", "H.n", "DD.n.l", 
        "UD.n.l", "H.l", "DD.l.Return", "UD.l.Return", "H.Return"
    ]
    
    TARGET_PASSWORD = ".tie5Roanl"

    def __init__(self, root):
        self.root = root
        self.root.title("Keystroke Logging Application (Python Replica)")
        
        self.store = KeyDataStore()
        self.press_index = 0
        self.release_index = 0
        self.sample_counts = {} # Dictionary to track samples per user

        # --- GUI components ---
        tk.Label(root, text="Username:").pack(pady=(10,0))
        self.username_entry = tk.Entry(root, width=50)
        self.username_entry.pack(pady=5)
        self.username_entry.insert(0, "default_user")

        # --- Add Radio Buttons for Label ---
        self.label_var = tk.StringVar(value="Genuine") # Default selection
        label_frame = tk.Frame(root)
        tk.Label(label_frame, text="Select Label:").pack(side=tk.LEFT, padx=5)
        tk.Radiobutton(label_frame, text="Genuine", variable=self.label_var, value="Genuine").pack(side=tk.LEFT)
        tk.Radiobutton(label_frame, text="Imposter", variable=self.label_var, value="Imposter").pack(side=tk.LEFT)
        label_frame.pack(pady=5)

        tk.Label(root, text=f"Type the password '{self.TARGET_PASSWORD}' and press Enter:").pack(pady=5)
        self.typing_area = tk.Entry(root, width=50, font=("Courier", 12))
        self.typing_area.pack(pady=5, padx=10)

        self.display_area = tk.Label(root, text="Ready for input.", wraplength=480)
        self.display_area.pack(pady=5)

        # --- Add Sample Counter Display ---
        self.count_label = tk.Label(root, text="", font=("Helvetica", 10, "italic"), fg="navy")
        self.count_label.pack(pady=5)


        # --- Bind key events ---
        self.typing_area.bind("<KeyPress>", self.key_pressed)
        self.typing_area.bind("<KeyRelease>", self.key_released)
        
        self.username_entry.focus_set()
        # Update counter when username changes
        self.username_entry.bind("<KeyRelease>", self.update_counter_display)
        self.update_counter_display() # Initial update

    def update_counter_display(self, event=None):
        """Updates the sample counter label based on the current username."""
        username = self.username_entry.get().strip()
        if username:
            count = self.sample_counts.get(username, 0)
            self.count_label.config(text=f"Samples collected for '{username}': {count} / {self.SAMPLES_PER_USER}")
        else:
            self.count_label.config(text="")


    def _reset_state(self):
        """Resets the application state for a new sample."""
        self.typing_area.delete(0, tk.END)
        self.store.initialize()
        self.press_index = 0
        self.release_index = 0

    def key_pressed(self, event):
        """Handles the key press event."""
        if event.keysym == "BackSpace":
            self._reset_state()
            self.display_area.config(text="State cleared. Please start over.")
            return

        if event.keysym == "Return":
            username = self.username_entry.get().strip()
            label = self.label_var.get()
            typed_text = self.typing_area.get()

            if not username:
                messagebox.showerror("Input Error", "Username cannot be empty.")
                return

            if typed_text == self.TARGET_PASSWORD:
                key_params_ms = self.store.process()
                key_params_ns = self.store.process_in_nano()

                if key_params_ms and key_params_ns:
                    self.generate_csv(key_params_ms, username, label)
                    self.generate_csv_in_nano(key_params_ns, username, label)
                    
                    # Update and display the sample count for the current user
                    self.sample_counts[username] = self.sample_counts.get(username, 0) + 1
                    self.update_counter_display()

                    self.display_area.config(text=f"Sample saved for '{username}' as '{label}'. Ready for next.")
                else:
                    self.display_area.config(text="Not enough keys typed to save a sample.")
            else:
                messagebox.showerror("Input Error", "The typed text does not match the target password. Please try again.")
                self.display_area.config(text="Incorrect input. Please try again.")

            self._reset_state()
            return
            
        typed_key = TypedKeyObject()
        typed_key.press_time_ms = int(time.time() * 1000)
        typed_key.press_time_ns = time.time_ns()
        
        self.store.store_typed_object(typed_key)
        self.press_index += 1

    def key_released(self, event):
        """Handles the key release event."""
        if event.keysym in ("BackSpace", "Return"):
            return

        key_object = self.store.get_key(self.release_index)
        if key_object:
            key_object.release_time_ms = int(time.time() * 1000)
            key_object.release_time_ns = time.time_ns()
            self.release_index += 1

    def generate_csv(self, key_params: list[float], username: str, label: str):
        """Saves millisecond data to a single, combined Keystrokes.csv file."""
        filename = "Keystrokes.csv"
        file_exists = os.path.isfile(filename)

        with open(filename, 'a', newline='') as f:
            writer = csv.writer(f)
            if not file_exists:
                writer.writerow(self.FILE_HEADER)
            
            writer.writerow([username, label] + key_params)
        print(f"Successfully appended millisecond data to {filename}")

    def generate_csv_in_nano(self, key_params: list[int], username: str, label: str):
        """Saves nanosecond data to a single, combined KeystrokesInNano.csv file."""
        filename = "KeystrokesInNano.csv"
        file_exists = os.path.isfile(filename)

        with open(filename, 'a', newline='') as f:
            writer = csv.writer(f)
            if not file_exists:
                writer.writerow(self.FILE_HEADER)

            writer.writerow([username, label] + key_params)
        print(f"Successfully appended nanosecond data to {filename}")

if __name__ == "__main__":
    # Create and run the application
    root = tk.Tk()
    app = KeystrokeGuiApp(root)
    root.mainloop()






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#https://github.com/fdechaumont/lmt-analysis
#https://github.com/chrisgdt/DELBOT-Mouse
#https://github.com/margitantal68/sapimouse